// Plugin Manager - Core plugin system for LlamB extension
console.log('PluginManager: Script execution started');

class PluginManager {
  constructor() {
    this.plugins = new Map(); // Map of pluginId -> plugin instance
    this.pluginRegistry = new Map(); // Map of pluginId -> plugin metadata
    this.enabledPlugins = new Set(); // Set of enabled plugin IDs
    this.storageKey = 'llamb-plugin-settings';
    this.initialized = false;
  }

  // Initialize plugin manager
  async initialize() {
    if (this.initialized) return;

    try {
      // Load plugin settings from storage
      await this.loadPluginSettings();
      
      // Register built-in plugins
      await this.discoverPlugins();
      
      // Load and activate enabled plugins
      await this.loadEnabledPlugins();
      
      this.initialized = true;
      console.log('PluginManager: Initialized successfully');
    } catch (error) {
      console.error('PluginManager: Failed to initialize:', error);
    }
  }

  // Discover available plugins
  async discoverPlugins() {
    // For now, register built-in plugins manually
    // In the future, this could scan a plugins directory
    
    // Register YouTube Captions plugin
    this.registerPlugin({
      id: 'youtube-captions',
      name: 'YouTube Captions',
      description: 'Extract captions from YouTube videos',
      version: '1.0.0',
      icon: 'ðŸ’¬',
      matches: ['*://www.youtube.com/watch*', '*://youtube.com/watch*'],
      permissions: ['extractContent'],
      scriptPath: 'plugins/youtube-captions/plugin.js',
      settings: {
        preferredLanguage: 'en',
        includeTimestamps: false,
        includeAutoGenerated: true
      }
    });
  }

  // Register a plugin
  registerPlugin(manifest) {
    this.pluginRegistry.set(manifest.id, manifest);
    console.log(`PluginManager: Registered plugin ${manifest.id}`);
  }

  // Load plugin settings from storage
  async loadPluginSettings() {
    try {
      const result = await chrome.storage.local.get(this.storageKey);
      const settings = result[this.storageKey] || {};
      
      this.enabledPlugins = new Set(settings.enabled || []);
      
      // Load individual plugin settings
      for (const [pluginId, pluginSettings] of Object.entries(settings.plugins || {})) {
        if (this.pluginRegistry.has(pluginId)) {
          const manifest = this.pluginRegistry.get(pluginId);
          manifest.settings = { ...manifest.settings, ...pluginSettings };
        }
      }
    } catch (error) {
      console.error('PluginManager: Error loading settings:', error);
    }
  }

  // Save plugin settings to storage
  async savePluginSettings() {
    try {
      const settings = {
        enabled: Array.from(this.enabledPlugins),
        plugins: {}
      };

      // Save individual plugin settings
      for (const [pluginId, manifest] of this.pluginRegistry) {
        if (manifest.settings) {
          settings.plugins[pluginId] = manifest.settings;
        }
      }

      await chrome.storage.local.set({
        [this.storageKey]: settings
      });
    } catch (error) {
      console.error('PluginManager: Error saving settings:', error);
    }
  }

  // Load and activate enabled plugins
  async loadEnabledPlugins() {
    for (const pluginId of this.enabledPlugins) {
      await this.loadPlugin(pluginId);
    }
  }

  // Load a specific plugin
  async loadPlugin(pluginId) {
    const manifest = this.pluginRegistry.get(pluginId);
    if (!manifest) {
      console.error(`PluginManager: Plugin ${pluginId} not found in registry`);
      return false;
    }

    if (this.plugins.has(pluginId)) {
      console.log(`PluginManager: Plugin ${pluginId} already loaded`);
      return true;
    }

    try {
      // Load plugin script
      const script = document.createElement('script');
      script.src = chrome.runtime.getURL(manifest.scriptPath);
      
      await new Promise((resolve, reject) => {
        script.onload = () => {
          // Plugin class should be globally available with name pattern: PluginClassName
          const className = this.getPluginClassName(pluginId);
          const PluginClass = window[className];
          
          if (!PluginClass) {
            reject(new Error(`Plugin class ${className} not found`));
            return;
          }

          try {
            // Create plugin instance with controlled API access
            const pluginApi = this.createPluginApi(pluginId);
            const plugin = new PluginClass(pluginApi, manifest);
            
            // Initialize plugin
            plugin.onInit();
            
            this.plugins.set(pluginId, plugin);
            console.log(`PluginManager: Loaded plugin ${pluginId}`);
            resolve();
          } catch (error) {
            reject(error);
          }
        };
        
        script.onerror = reject;
        document.head.appendChild(script);
      });

      return true;
    } catch (error) {
      console.error(`PluginManager: Failed to load plugin ${pluginId}:`, error);
      return false;
    }
  }

  // Create controlled API interface for plugin
  createPluginApi(pluginId) {
    const manifest = this.pluginRegistry.get(pluginId);
    
    return {
      // Plugin identification
      getPluginId: () => pluginId,
      getManifest: () => ({ ...manifest }),
      
      // Settings access
      getSetting: (key) => manifest.settings[key],
      setSetting: async (key, value) => {
        manifest.settings[key] = value;
        await this.savePluginSettings();
      },
      
      // Page context access
      getPageContext: () => this.getCurrentPageContext(),
      
      // Content chips API
      addContextChip: (chipData) => this.addContextChip(pluginId, chipData),
      removeContextChip: () => this.removeContextChip(pluginId),
      
      // Event system
      emit: (event, data) => this.emitPluginEvent(pluginId, event, data),
      on: (event, callback) => this.onPluginEvent(pluginId, event, callback),
      
      // Logging
      log: (...args) => console.log(`Plugin[${pluginId}]:`, ...args),
      warn: (...args) => console.warn(`Plugin[${pluginId}]:`, ...args),
      error: (...args) => console.error(`Plugin[${pluginId}]:`, ...args),
      
      // Storage (scoped to plugin)
      storage: {
        get: async (key) => {
          const result = await chrome.storage.local.get(`plugin-${pluginId}-${key}`);
          return result[`plugin-${pluginId}-${key}`];
        },
        set: async (key, value) => {
          await chrome.storage.local.set({ [`plugin-${pluginId}-${key}`]: value });
        }
      }
    };
  }

  // Get plugin class name from plugin ID
  getPluginClassName(pluginId) {
    return pluginId.split('-').map(part => 
      part.charAt(0).toUpperCase() + part.slice(1)
    ).join('') + 'Plugin';
  }

  // Get current page context
  getCurrentPageContext() {
    return {
      url: window.location.href,
      title: document.title,
      domain: window.location.hostname,
      selectedText: window.getSelection()?.toString() || '',
      timestamp: new Date().toISOString()
    };
  }

  // Enable a plugin
  async enablePlugin(pluginId) {
    if (!this.pluginRegistry.has(pluginId)) {
      console.error(`PluginManager: Plugin ${pluginId} not found`);
      return false;
    }

    this.enabledPlugins.add(pluginId);
    await this.savePluginSettings();
    
    // Load plugin if not already loaded
    const success = await this.loadPlugin(pluginId);
    if (success) {
      const plugin = this.plugins.get(pluginId);
      if (plugin && typeof plugin.onActivate === 'function') {
        plugin.onActivate();
      }
    }
    
    return success;
  }

  // Disable a plugin
  async disablePlugin(pluginId) {
    this.enabledPlugins.delete(pluginId);
    await this.savePluginSettings();
    
    const plugin = this.plugins.get(pluginId);
    if (plugin) {
      if (typeof plugin.onDeactivate === 'function') {
        plugin.onDeactivate();
      }
      
      // Remove context chip if present
      this.removeContextChip(pluginId);
      
      // Don't unload the plugin, just deactivate it
    }
    
    return true;
  }

  // Check if plugin is enabled
  isPluginEnabled(pluginId) {
    return this.enabledPlugins.has(pluginId);
  }

  // Get list of all available plugins
  getAvailablePlugins() {
    return Array.from(this.pluginRegistry.values());
  }

  // Get list of enabled plugins
  getEnabledPlugins() {
    return Array.from(this.pluginRegistry.values()).filter(p => this.enabledPlugins.has(p.id));
  }

  // Check if plugin should run on current page
  shouldPluginRun(pluginId) {
    const manifest = this.pluginRegistry.get(pluginId);
    if (!manifest || !this.enabledPlugins.has(pluginId)) {
      return false;
    }

    const currentUrl = window.location.href;
    return manifest.matches.some(pattern => {
      // Convert glob pattern to regex
      const regex = new RegExp(
        pattern.replace(/\*/g, '.*').replace(/\./g, '\\.')
      );
      return regex.test(currentUrl);
    });
  }

  // Notify plugins of page changes
  async onPageChange() {
    console.log('PluginManager: onPageChange called for', this.plugins.size, 'plugins');
    for (const [pluginId, plugin] of this.plugins) {
      console.log(`PluginManager: Checking plugin ${pluginId}, shouldRun:`, this.shouldPluginRun(pluginId));
      if (this.shouldPluginRun(pluginId)) {
        try {
          if (typeof plugin.onPageChange === 'function') {
            console.log(`PluginManager: Calling onPageChange for ${pluginId}`);
            await plugin.onPageChange();
          }
        } catch (error) {
          console.error(`PluginManager: Error in ${pluginId} onPageChange:`, error);
        }
      }
    }
  }

  // Context chip management
  addContextChip(pluginId, chipData) {
    if (typeof window.addPluginContextChip === 'function') {
      window.addPluginContextChip(pluginId, chipData);
    }
  }

  removeContextChip(pluginId) {
    if (typeof window.removePluginContextChip === 'function') {
      window.removePluginContextChip(pluginId);
    }
  }

  // Event system
  emitPluginEvent(pluginId, event, data) {
    // Simple event system - can be enhanced later
    const eventName = `plugin-${pluginId}-${event}`;
    window.dispatchEvent(new CustomEvent(eventName, { detail: data }));
  }

  onPluginEvent(pluginId, event, callback) {
    const eventName = `plugin-${pluginId}-${event}`;
    window.addEventListener(eventName, callback);
  }

  // Get plugin content for chat context
  async getPluginContent(pluginId) {
    const plugin = this.plugins.get(pluginId);
    if (!plugin || !this.shouldPluginRun(pluginId)) {
      return null;
    }

    try {
      if (typeof plugin.getContent === 'function') {
        return await plugin.getContent();
      }
    } catch (error) {
      console.error(`PluginManager: Error getting content from ${pluginId}:`, error);
    }
    
    return null;
  }
}

console.log('PluginManager: Class definition completed');

// Export for use in content script
console.log('PluginManager: Making class available globally');
window.PluginManager = PluginManager;